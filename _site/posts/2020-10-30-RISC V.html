<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta http-equiv="x-ua-compatible" content="ie=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Ryokou - 2020-10-30-RISC V</title>
        <link rel="stylesheet" href="../web/static/main.css" />
        <script src="../web/static/main.bundle.js"></script>
        <style>
            header {
                width: 100%;
            }
            nav {
                width: 100%;
            }

            header nav {
                display: flex;
                justify-content: space-between;
            }

            footer {
                width: 100%;
                text-align: center;
            }
        </style>
    </head>

    <body>
        <header>
            <nav>
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../archive.html">Archive</a>
            </nav>
        </header>

        <style>
    /* main {
        display: flex;
        flex-direction: column;
        align-items: center;
    }

    article {
        max-width: 680px;
    } */
</style>

<main role="main">
    <h1>2020-10-30-RISC V</h1>
    <article>
        <!-- <section class="header"></section> -->
        <section><p indent="0">6 种基本指令格式</p>
<p indent="1">- R 型：用于 register - register </p>
<p indent="1">- I 型：用于短立即数和访存 Load 操作 （有 12 位用于 Imm</p>
<p indent="1">- U 型：用于长立即数 （有 20 位用于 Imm</p>
<p indent="2">（RISC V 指令中所有的立即数总是符号扩展</p>
<p indent="1">- S 型：用于访存 Store 操作</p>
<p indent="1">- B 型：用于条件跳转操作</p>
<p indent="1">- J 型：用于无条件跳转</p>
<p indent="0">所有位全是 1 或 全是 0 的指令是非法指令</p>
<p indent="0">RV32I 有 31 个通用寄存器和一个恒为 0 的 X0 寄存器；在 RISC V 中，PC 不是通用寄存器</p>
<p indent="0">lui 将 20 位常量加载到寄存器的高 20 位</p>
<p indent="0">auipc 将20 位常量加载到 PC 的高 20 位</p>
<p indent="0">e.g., 用 lui 加载立即数到寄存器的高 20 位，再用一般的立即数指令弄低 12 位可构造出构造大的常量</p>
<p indent="0">e.g., 用 auipc 的 20 位与 jalr 的 12 位立即数的组合可以将执行流跳转到任何 32 位 PC 相对位置</p>
<p indent="0">除 32 位的 lw, sw 外，RV32I 还支持</p>
<p indent="1">加载有符号和无符号的字节和半字（lb, lbu, lh, lhu</p>
<p indent="2">都将被[符号]扩展后再写入寄存器</p>
<p indent="1">存储字节和半字（sb, sh</p>
<p indent="0">加载与存储仅支持唯一的位置模式：位偏移寻址模式</p>
<p indent="1">符号扩展 12 位立即数到基地址寄存器</p>
<p indent="0">RV32I 基于比较两个寄存器的结果进行分支跳转（有的 architecture 用控制位记录溢出等，并根据此进行跳转</p>
<p indent="0">由于 RISC V 的指令长度必须是 2 字节的倍数，所以分支指令的寻址方式是 12 位立即数乘 2 后符号扩展再加到 PC 上作为 target addr</p>
<p indent="0">RV32A 有 2 种类型的原子操作</p>
<p indent="1">- atomic memory operation</p>
<p indent="2">AMO 对内存执行一个原子操作，并将寄存器设置为操作前的内存值；原子表示内存读写之间的过程不会被打断，内存值不会被其它处理器修改</p>
<p indent="1">- load reserved / store conditional</p>
<p indent="0">RISC V 有宽松的内存一致性模型（relaxed memory consistency model）因此其它线程看到的内存访问可以是乱序的</p>
<p indent="0">所有的 RV32A 指令都有一个请求位 aq 一个释放位 rl</p>
<p indent="0">RISC V 提供三种模式：user mode, supervisor mode, machine mode </p>
<p indent="0">machine mode 是硬件线程可以执行的最高权限模式，对内存， I/O 等底层功能有完全的控制权</p>
<p indent="0">machine mode 最重要的特性是控制和处理异常；RISC V 的异常 (exception) 分为两类</p>
<p indent="1">- 同步异常，再指令执行期间产生</p>
<p indent="1">- 中断 interrupt ，与指令异步的外部事件；有三种标准中断源：</p>
<p indent="2">- 软件：通过像内存映射寄存器种存数并通常用一个 hart 来中断另一个 hart</p>
<p indent="2">- 时钟：当实时计数器 mtime 大于 hart 的时间比较器（一个名为 mtimecmp 的内存映射寄存器）时触发时钟中断</p>
<p indent="2">- 外部来源：由平台级中断控制器引发（大部分外部设备连接到这个中断控制器）</p>
<p indent="0">RISC V 的异常 are precise：所有异常前的指令已完全执行 & 所有异常后的指令还未开始执行</p>
<p indent="0">8 个 Control and Status Registers 时机器模式下异常处理的必要部分</p>
<p indent="1">- Machine Trap Vector: 保存发生异常时需跳转到的地址</p>
<p indent="1">- Machine Exception PC: 指向发生异常的指令</p>
<p indent="2">对于同步异常，mepc 指向发生异常的指令</p>
<p indent="2">对于中断，指向应恢复的位置</p>
<p indent="1">- Machine Exception Cause: 异常发生的种类</p>
<p indent="1">- Machine Interrupt Enable: 列出目前 CPU 能处理和必须忽略的中断</p>
<p indent="2">每个中断再 MIE 中都有对应的使能位，例如 MIE[7] 对应时钟中断</p>
<p indent="1">- Machine Interrupt Pending: lists pending interrupts</p>
<p indent="1">- Machine Trap Value: 保存了 trap 的附加信息（地址例外中出错的地址，非法指令的指令本身</p>
<p indent="1">- 通常包含指向附加临时内存空间的指针</p>
<p indent="2">在中断处理工程中可能会用到部分寄存器，为避免覆盖，中断处理程序会用附加内存空间保存用到的寄存器</p>
<p indent="3">一个异常处理程序会先用 csrw 指令交换 a0 与 mscratch 再用 sw 与 a0 来保存寄存器。在中断处理完成后用 lw 与 a0 恢复寄存器，再交换回 a0 与 mscratch。最后用 mret 返回</p>
<p indent="1">- Machine Status: 包含全局设定是否开启中断（MIE）等信息</p>
<p indent="2">若 mstatus.MIE = 1 & MIE[7] = 1 & MIP[7] = 1 则 CPU 可处理时钟中断</p>
<p indent="0">当一个 hart 发生异常时，硬件自动做以下处理</p>
<p indent="1">1. 异常指令的 PC vei存在 mepc 中；PC 被设置为 mtvec</p>
<p indent="1">2. 根据异常来源设置 mcause 并设置 mtval</p>
<p indent="1">3. mstatus.mpie = mstatus.mie; mstatus.mie = 0</p>
<p indent="1">4. 将异常前的权限模式保存在 mstatus.mpp 中，并切换到 machine mode</p>
<p indent="0">有时在处理异常的过程中需要跳转到更高优先级的中断，然而 CSRs 只有一个副本，接受一个更高优先级的中断会破坏旧值。一个抢占式的中断 handler 在启用终端前将 CSRs 保存到内存栈中，在推出前禁用中断并恢复 CSRs</p>
<p indent="0">通过将 mstatus.mpp 设置为 u 然后执行 mret 指令，软件可以从 machine mode 进入 user mode</p>
<p indent="0">实现了 machine 和 user mode 的处理器具有一个叫做 physical memory protection 的功能：允许 machine mode 指定 user mode 可访问的内存地址</p>
<p indent="0">PMP 包含几个地址寄存器和相应的配置寄存器，这些配置寄存器可授予或拒绝读写执行权限</p>
<p indent="0">当处于 user mode 对内存进行操作时，将地址和所有的 PMP 地址寄存器进行比较，若地址大于第 i 个地址寄存器小于第 i + 1 个地址寄存器，则由第 i + 1 个配置寄存器进行校验</p>
<p indent="0">与 user mode 相同，supervisor mode 下也不能使用 machine mode 的 CSRs 和指令切受 PMP 限制</p>
<p indent="0">默认情况下，所有发生异常的时候，控制权都被移交到 machine mode 的异常处理程序，但 unix 系统中大多数异常都进行在 supervisor mode 下的系统调用。RISC V 提供了一种异常委托机制，可选择性地将终端和异常委托给 supervisor mode 处理</p>
<p indent="1">Machine Interrupt Delegation CSR 控制将哪些中断委托给 supervisor mode</p>
<p indent="0">与 machine mode 类似，supervisor mode 有对应的异常处理 CSRs：sie, sip, sepc, stvec, scause, sscratch, stval, sstatus; mret 对应 sret 指令。异常的处理流程也和 machine mode 类似</p>
<p indent="0">supervisor mode 提供了虚拟内存，启用分页的时候大多数地址（包括 load/store 和 pc 中的地址）都是虚拟地址。</p>
<p indent="0">要访问物理内存，它们必须通过页表被转换为珍重的物理地址。</p>
<p indent="0">RISC V 的分页方案以 SvX 命名，其中 X 为虚拟地址的长度。</p>
<p indent="1">- 例如 RV32 采用 Sv32 方案，采用了两级页表，每页 4KB</p>
<p indent="1">- 例如 RV64 采用 Sv39 方案，采用了三级页表，每页 4KB</p></section>
    </article>
</main>

    </body>
</html>
