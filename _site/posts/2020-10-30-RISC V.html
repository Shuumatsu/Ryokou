<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta http-equiv="x-ua-compatible" content="ie=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Ryokou - 2020-10-30-RISC V</title>
        <link rel="stylesheet" href="../web/static/main.css" />
        <script src="../web/static/main.bundle.js"></script>
        <style>
            header {
                width: 100%;
            }
            nav {
                width: 100%;
            }

            header nav {
                display: flex;
                justify-content: space-between;
            }

            footer {
                width: 100%;
                text-align: center;
            }
        </style>
    </head>

    <body>
        <header>
            <nav>
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../archive.html">Archive</a>
            </nav>
        </header>

        <style>
    /* main {
        display: flex;
        flex-direction: column;
        align-items: center;
    }

    article {
        max-width: 680px;
    } */
</style>

<main role="main">
    <h1>2020-10-30-RISC V</h1>
    <article>
        <!-- <section class="header"></section> -->
        <section><p indent="0">Software threads are threads of execution managed by the operating system.</p>
<p indent="0">Hardware threads are a feature of some processors that allow better utilisation of the processor under some circumstances. They may be exposed to/by the operating system as appearing to be additional cores ("hyperthreading").</p>
<p indent="0">One hardware thread can run many software threads. （time-slicing</p>
<p indent="0">6 种基本指令格式</p>
<p indent="1">- R 型：用于 register - register </p>
<p indent="1">- I 型：用于短立即数和访存 Load 操作 （有 12 位用于 Imm</p>
<p indent="1">- U 型：用于长立即数 （有 20 位用于 Imm</p>
<p indent="2">（RISC V 指令中所有的立即数总是符号扩展</p>
<p indent="1">- S 型：用于访存 Store 操作</p>
<p indent="1">- B 型：用于条件跳转操作</p>
<p indent="1">- J 型：用于无条件跳转</p>
<p indent="0">所有位全是 1 或 全是 0 的指令是非法指令</p>
<p indent="0">RV32I 有 31 个通用寄存器和一个恒为 0 的 X0 寄存器；在 RISC V 中，PC 不是通用寄存器</p>
<p indent="0">lui 将 20 位常量加载到寄存器的高 20 位</p>
<p indent="0">auipc 将20 位常量加载到 PC 的高 20 位</p>
<p indent="0">e.g., 用 lui 加载立即数到寄存器的高 20 位，再用一般的立即数指令弄低 12 位可构造出构造大的常量</p>
<p indent="0">e.g., 用 auipc 的 20 位与 jalr 的 12 位立即数的组合可以将执行流跳转到任何 32 位 PC 相对位置</p>
<p indent="0">除 32 位的 lw, sw 外，RV32I 还支持</p>
<p indent="1">加载有符号和无符号的字节和半字（lb, lbu, lh, lhu</p>
<p indent="2">都将被[符号]扩展后再写入寄存器</p>
<p indent="1">存储字节和半字（sb, sh</p>
<p indent="0">加载与存储仅支持唯一的位置模式：位偏移寻址模式</p>
<p indent="1">符号扩展 12 位立即数到基地址寄存器</p>
<p indent="0">RV32I 基于比较两个寄存器的结果进行分支跳转（有的 architecture 用控制位记录溢出等，并根据此进行跳转</p>
<p indent="0">由于 RISC V 的指令长度必须是 2 字节的倍数，所以分支指令的寻址方式是 12 位立即数乘 2 后符号扩展再加到 PC 上作为 target addr</p>
<p indent="0">RV32A 有 2 种类型的原子操作</p>
<p indent="1">- atomic memory operation</p>
<p indent="2">AMO 对内存执行一个原子操作，并将寄存器设置为操作前的内存值；原子表示内存读写之间的过程不会被打断，内存值不会被其它处理器修改</p>
<p indent="1">- load reserved / store conditional</p>
<p indent="0">RISC V 有宽松的内存一致性模型（relaxed memory consistency model）因此其它线程看到的内存访问可以是乱序的</p>
<p indent="0">所有的 RV32A 指令都有一个请求位 aq 一个释放位 rl</p>
<p indent="0">RISC V 提供三种模式：user mode, supervisor mode, machine mode </p>
<p indent="0">machine mode 是硬件线程可以执行的最高权限模式，对内存， I/O 等底层功能有完全的控制权</p>
<p indent="0">machine mode 最重要的特性是控制和处理异常；RISC V 的异常 (exception) 分为两类</p>
<p indent="1">- 同步异常，再指令执行期间产生</p>
<p indent="1">- 中断 interrupt ，与指令异步的外部事件；有三种标准中断源：</p>
<p indent="2">- 软件：通过像内存映射寄存器种存数并通常用一个 hart 来中断另一个 hart</p>
<p indent="2">- 时钟：当实时计数器 mtime 大于 hart 的时间比较器（一个名为 mtimecmp 的内存映射寄存器）时触发时钟中断</p>
<p indent="2">- 外部来源：由平台级中断控制器引发（大部分外部设备连接到这个中断控制器）</p>
<p indent="0">RISC V 的异常 are precise：所有异常前的指令已完全执行 & 所有异常后的指令还未开始执行</p>
<p indent="0">8 个 Control and Status Registers 时机器模式下异常处理的必要部分</p>
<p indent="1">- Machine Trap Vector: 保存发生异常时需跳转到的地址</p>
<p indent="1">- Machine Exception PC: 指向发生异常的指令</p>
<p indent="2">对于同步异常，mepc 指向发生异常的指令</p>
<p indent="2">对于中断，指向应恢复的位置</p>
<p indent="1">- Machine Exception Cause: 异常发生的种类</p>
<p indent="1">- Machine Interrupt Enable: 列出目前 CPU 能处理和必须忽略的中断</p>
<p indent="2">每个中断再 MIE 中都有对应的使能位，例如 MIE[7] 对应时钟中断</p>
<p indent="1">- Machine Interrupt Pending: lists pending interrupts</p>
<p indent="1">- Machine Trap Value: 保存了 trap 的附加信息（地址例外中出错的地址，非法指令的指令本身</p>
<p indent="1">- Machine Scratch 通常包含指向附加临时内存空间的指针</p>
<p indent="2">在中断处理工程中可能会用到部分寄存器，为避免覆盖，中断处理程序会用附加内存空间保存用到的寄存器</p>
<p indent="3">一个异常处理程序会先用 csrw 指令交换 a0 与 mscratch 再用 sw 与 a0 来保存寄存器。在中断处理完成后用 lw 与 a0 恢复寄存器，再交换回 a0 与 mscratch。最后用 mret 返回</p>
<p indent="1">- Machine Status: 包含全局设定是否开启中断（MIE）等信息</p>
<p indent="2">若 mstatus.MIE = 1 & MIE[7] = 1 & MIP[7] = 1 则 CPU 可处理时钟中断</p>
<p indent="0">CSRs 通过以下指令操作以及其对应的立即数版本：</p>
<p indent="1">csrrw dest, csr, src 将 src 写入 csr 并将其旧值写入 dest</p>
<p indent="1">csrrs dest, csr, src 通过 or src csr 操作将 src 写入 csr 并将其旧值写入 dest</p>
<p indent="1">csrrc dest, csr, src 通过 and src csr 操作将 src 写入 csr 并将其旧值写入 dest</p>
<p indent="0">当一个 hart 发生异常时，硬件自动做以下处理</p>
<p indent="1">1. 异常指令的 PC vei存在 mepc 中；PC 被设置为 mtvec</p>
<p indent="1">2. 根据异常来源设置 mcause 并设置 mtval</p>
<p indent="1">3. mstatus.mpie = mstatus.mie; mstatus.mie = 0</p>
<p indent="1">4. 将异常前的权限模式保存在 mstatus.mpp 中，并切换到 machine mode</p>
<p indent="0">有时在处理异常的过程中需要跳转到更高优先级的中断，然而 CSRs 只有一个副本，接受一个更高优先级的中断会破坏旧值。一个抢占式的中断 handler 在启用终端前将 CSRs 保存到内存栈中，在推出前禁用中断并恢复 CSRs</p>
<p indent="0">通过将 mstatus.mpp 设置为 u 然后执行 mret 指令，软件可以从 machine mode 进入 user mode</p>
<p indent="0">实现了 machine 和 user mode 的处理器具有一个叫做 physical memory protection 的功能：允许 machine mode 指定 user mode 可访问的内存地址</p>
<p indent="0">PMP 包含几个地址寄存器和相应的配置寄存器，这些配置寄存器可授予或拒绝读写执行权限</p>
<p indent="0">当处于 user mode 对内存进行操作时，将地址和所有的 PMP 地址寄存器进行比较，若地址大于第 i 个地址寄存器小于第 i + 1 个地址寄存器，则由第 i + 1 个配置寄存器进行校验</p>
<p indent="0">与 user mode 相同，supervisor mode 下也不能使用 machine mode 的 CSRs 和指令切受 PMP 限制</p>
<p indent="0">默认情况下，所有发生异常的时候，控制权都被移交到 machine mode 的异常处理程序，但 unix 系统中大多数异常都进行在 supervisor mode 下的系统调用。RISC V 提供了一种异常委托机制，可选择性地将终端和异常委托给 supervisor mode 处理</p>
<p indent="1">Machine Interrupt Delegation CSR 控制将哪些中断委托给 supervisor mode</p>
<p indent="0">与 machine mode 类似，supervisor mode 有对应的异常处理 CSRs：sie, sip, sepc, stvec, scause, sscratch, stval, sstatus; mret 对应 sret 指令。异常的处理流程也和 machine mode 类似</p>
<p indent="0">RISC V ISA 采用 12-bit encoding space for up to 4096 CSRs. 惯例上，最高两位用来表示在指定 privilege level 下的读写权限，次高两位表示该 CSR 要求的最低 privilege level</p>
<p indent="1">（一个可写寄存器也可能部分位是只读的，对这些位进行写入会被忽略</p>
<p indent="0">CSR Field Specification</p>
<p indent="1">- Reserved Writes Preserve Values, Reads Ignore Values (WPRI</p>
<p indent="2">有些 fields 被保留 for future use。软件应忽略从中读取到的值并且在写入寄存器时不改变其值</p>
<p indent="1">- Write/Read Only Legal Values (WLRL</p>
<p indent="2">对某些 fields 来说，只有部分 bit encoding 是有效的。软件不应向这些 fields 中写入非法的值并且不应假定读出的值是合法的除非上次写入的是一个有效的值</p>
<p indent="1">- Write Any Values, Read Legal Values (WARL</p>
<p indent="2">对某些 fields 来说，只有部分 bit encoding 是有效的。允许向其中写入任意值并且保证任意时候读出的值都是合法的</p>
<p indent="3">- 若上次写入的值是不合法的，则根据实现，可能返回任意的一个合法的值</p>
<p indent="3">- 若上次写入的值是合法的，则保证返回该合法值</p>
<p indent="0"><b>Machine ISA Register (misa)</b> <code-snippet>[MXL 2 bits - WARL, WLRL, EXTENSIONS - 26 bits - WARL]
</code-snippet> reporting the ISA supported byt the hart; 该寄存器在任何实现中都必须可读</p>
<p indent="1">其最高两位 MXL 表示 ISA 宽度，可选值为 32, 64 以及 128。在支持多种 ISA 宽度的实现上，该 field 是可写的</p>
<p indent="1">最低 0 到 25 的 26 位 EXTENSIONS field 的每一个 bit 根据其位置表示从 A 到 Z 的 extension。e.g., bit-2 代表 C 表示 Compress Ext</p>
<p indent="1">读取 misa 可能返回 0 表示未实现此 CSR，此时需要用非标准的机制来获取信息</p>
<p indent="2">例如当 misa 返回 0 时获取 ISA 宽度：将立即数 4 置于一个寄存器中，每次向左移动 31 位。若一次位移后归零，则是 RV32，两次则是 RV64，三次则是 RV128</p>
<p indent="0"><b>Machine Vendor ID Register (mvendorid)</b> <code-snippet>[Bank - 25 bits, offset - 7 bits]
</code-snippet> 是一个 32 位只读寄存器 providing the JEDEC manufacture ID of the provider of the core; 该寄存器在任何实现中都必须可读</p>
<p indent="1">读取该寄存器时返回 0 表示未实现或表明这是一个 non-commercial 实现</p>
<p indent="0"><b>Machine Architecture ID Register (marchid)</b> <code-snippet>[Architecture ID - MXLEN bits]
</code-snippet> 是一个 MXLEN-bit 只读寄存器 encoding the base microarchitecture of the hart; 该寄存器在任何实现中都必须可读</p>
<p indent="1">读取该寄存器时返回 0 表示未实现</p>
<p indent="0">The combination of mvendorid and marchid should uniquely identify the type of hart microarchitecture that is implemented.</p>
<p indent="0"><b>Machine Implementation ID Register (mimpid)</b> <code-snippet>[Implementation - MXLEN bits]
</code-snippet> provides a unique encoding of the version of the processor implementation; 该寄存器在任何实现中都必须可读</p>
<p indent="1">读取该寄存器时返回 0 表示未实现</p>
<p indent="0"><b>Hart ID Register (mhartid)</b> 是一个 MXLEN-bit 只读寄存器，containing the integer ID of the hardware thread running the code; 该寄存器在任何实现中都必须可读</p>
<p indent="1">要求至少有一个额 hart 有 ID 0 并且所有 hart 有不同的 ID</p>
<p indent="0"><b>Machine Status Register (mstatus)</b> 是一个 MXLEN-bit 读写寄存器。mstatus keeps track of and controls the hart’s 当前状态。Restricted views of the mstatus register appear as the sstatus and ustatus registers in the S-level and U-level ISAs respectively.</p>
<code-snippet indent="0" block="true">for RV32: 
[
SD, 8 bits - WPRI, TSR, TW, TVM, MXR, SUM, MPRV, XS - 2 bits, FS - 2 bits, 
MPP - 2bits, WPRI - 2 bits, SPP, MPIE, WPRI, SPIE, UPIE, MIE, WPRI, SIE, UIE
]

for RV64:
[

]
</code-snippet>
<p indent="0">每个 privilege mode 在其对应的状态寄存器中都有 global interrupt-enable bits (MIE, SIE, UIE). 这些位主要是用来保证在当前 privilege mode 中中断处理程序的原子性</p>
<p indent="0">在 privilege mode x 下，当 xIE = 1 时，中断是全局 enabled；当 xIE = 0 时，中断是全局 disabled</p>
<p indent="0">为了支持 nested traps，每个 privilege mode x 都有 two-level stack of interrupt-enable bits and privilege modes:</p>
<p indent="1">- xPIE 记录当前 trap 之前的 interrupt-enable bit</p>
<p indent="1">- xPP 记录当前 trap 之前的 privilege mode</p>
<p indent="0">All harts in a system must employ the same PTE-update scheme as each other</p>
<p indent="0">supervisor mode 提供了虚拟内存，启用分页的时候大多数地址（包括 loa  d/store 和 pc 中的地址）都是虚拟地址。</p>
<p indent="0">要访问物理内存，它们必须通过页表被转换为真正的物理地址。</p>
<p indent="0">RISC V 的分页方案以 SvX 命名，其中 X 为虚拟地址的长度。</p>
<p indent="1">- 例如 RV32 采用 Sv32 方案，采用了两级页表，每页 4KB</p>
<p indent="1">- 例如 RV64 采用 Sv39 方案（通常），采用了三级页表，每页 4KB</p>
<p indent="0">当 satp register 的 MODE field 是 Sv32 时，supervisor 运行在 32-bit paged virtual-memory system. 在该模式下 supervisor and user 虚拟地址通过遍历  radix-tree 结构的页表来 translated into 物理地址。</p>
<p indent="1">Sv32 virtual address:  <code-snippet>(VPN[1] - 10 bits, VPN[0] - 10 bits, page offset - 12 bits)
</code-snippet></p>
<p indent="1">Sv32 physical address:  <code-snippet>(PPN[1] - 12 bits, PPN[0] - 10 bits, page offset - 12 bits)
</code-snippet></p>
<p indent="1">Sv32 page  table entry:  <code-snippet>(PPN[1] - 12 bits, PPN[0] - 10 bits, RSW - 2 bits, D, A, G, U, X, W, R, V)
</code-snippet></p>
<p indent="2">the V bits indicates 该 PTE 是否有效</p>
<p indent="2">R, W, and X indicate 权限以及该 PTE 指向下一级页表</p>
<code-snippet indent="0" block="true">X | W | R || Meaning
0 | 0 | 0 || Pointer to next level of page table
0 | 0 | 1 || Read-only page
0 | 1 | 0 || Reserved for future use
0 | 1 | 1 || Read-write page
1 | 0 | 0 || Execute-only page
1 | 0 | 1 || Read-execute page
1 | 1 | 0 || Reserved for future use
1 | 1 | 1 || Read-write-execute page
</code-snippet>
<p indent="2">the U bit indicates whether the page is accessible to user mode。通常情况下 supervisor mode operates with the SUM bit clear，supervisor mode 不能访问用户页，但是如果 SUM bit is set, supervisor mode 也能访问用户页</p>
<p indent="2">the G bit 指定全局映射，意味着该映射存在于所有地址空间中（如果是一个非页 PTE 被设置为 global 则其 subsequent levels of the page table are global.</p>
<p indent="2">Each leaf PTE contains an accessed (A) and dirty (D) bit. </p>
<p indent="3">The A bit indicates the virtual page has been read, written, or fetched from since the last time the A bit was cleared.</p>
<p indent="3">The D bit indicates the virtual page has been written since the last time the D bit was cleared.</p>
<p indent="0">20 位的 VPN is translated into 22 位的 physical page number (PPN), while the offset is untranslated. 结果的 supervisor-level 物理地址在经过 physical memory protection structures 检查后 converted to machine-level 物理地址</p>
<p indent="0">Sv32 page tables 由 2e10 PTE 组成，每个 4 bytes。一个页表总是一页大小并且总是按页对齐的。根页表的 physical page number 被存储 在 satp 寄存器中。</p>
<p indent="0">Virtual Address Translation Process</p>
<p indent="1">1. 通过 satp.ppn * page_size 得到根页表物理地址</p>
<p indent="1">2. 根据 page_table_addr + va.vpn[i] * pte_size 得到当前层级下对应的 pte 地址</p>
<p indent="2">如果访问 pte violates a PMA or PMP check，抛出一个 access exception</p>
<p indent="1">3. 检查 pte 的标志位，若有问题则抛出一个 page-fault exception</p>
<p indent="1">4. 若当前 pte 指向下一层页表，则根据 pte.ppn * page_size 得到下一级页表地址</p>
<p indent="0">根据 pte 的标志位以及，mstatus.SUN 以及 mstatus.MXR 检查是否允许访问，若不则抛出一个 page-fault exception</p>
<code-snippet indent="0" block="true">la: load absolute address
li: load immediate
csrr: read csr
</code-snippet>
<p indent="0">kernel/kernel.ld 声明 architecture 为 riscv，入口为 _entry</p>
<p indent="0">将代码起始位置设置为内存 0x80000000 处（更低处的内存用于 I/O）</p>
<p indent="0">Xv6 从 kernel/entry.S （_entry) 开始执行，_entry 为 C 代码初始化栈</p>
<p indent="1">对每个 CPU：sp = stack0 + (hartid * 4096) 其中 stack0 定义在 kernel/start.c 中</p>
<p indent="0">而后跳转到 start() in kernel/start.c</p>
<p indent="0">kernel/start.c 中</p>
<p indent="1">为每个 CPU 定义了栈 char stack0[4096 * NCPU]</p>
<p indent="1">为每个 CPU 定义了 uint64 mscratch0[NCPU * 32] 用于 interrupt</p>
<p indent="0">在 start() 中设置 MPP 为 supervisor mode，设置 mepc 为 main</p>
<p indent="0">以在 machine mode 下进行必要的处理后使用 mret 进入 supervisor mode</p>
<p indent="0">禁用页表</p>
<p indent="0">代理所有 interrupts and exceptions 到 supervisor mode</p>
<p indent="0">timerinit();</p>
<p indent="0">保存每个 CPU 的 hartid 到它的 thread pointer register 用于 cpuid()</p>
<p indent="0">执行 mret （跳转到 kernel/main.c main(）</p>
<p indent="0">kernel/main.c main() 中的逻辑仅在 cpu0 中执行</p>
<p indent="0">初始化 console </p>
<p indent="0">kinit() 初始化 physical page allocator</p>
<p indent="0">kvminit() create kernel page table</p>
<p indent="0">kvminithart() Switch h/w page table register to the kernel's page table, and enable paging.</p>
<p indent="0">procinit();  // process table</p>
<p indent="0">kernel/kalloc.c </p>
<p indent="0">在 kernel/kernel.ld 中定义了内核代码后的第一个地址 extern char end[]</p>
<p indent="0">定义了一个带锁的结构体 kmem，其主体为一个链表，指向一串空闲的物理页</p>
<p indent="0">void kfree(void* pa) free 以 pa 开头的一页大小的内存</p>
<p indent="1">填入垃圾数据以 catch dangling refs</p>
<p indent="1">加入到 kmem.freelist</p>
<p indent="0">void freerange(void* pa_start, void* pa_end) 通过 kfree free 区间内的所有页 pa_start 会向上页对齐</p>
<p indent="0">void* kalloc(void) 从 kmem 中分配一页物理内存，如果无法分配则返回 0</p>
<p indent="0">kernel/vm.c </p>
<p indent="0">定义了一个内核页表 kernel_pagetable</p>
<p indent="0">void kvminit()</p>
<p indent="1">分配一个空页 for kernel_pagetable</p>
<p indent="0">void kvmmap(uint64 va, uint64 pa, uint64 sz, int perm) 在 kernel_pagetable 上 va 与 pa 之间添加一个映射，如果映射失败则抛出异常</p>
<p indent="0">int mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm)</p>
<p indent="0">从 va 与 pa 开始 为 pagetable 建立映射，如果</p>
<p indent="0">kernel/proc.c </p>
<p indent="0">void procinit(void) 在开机时初始化 proc table</p>
<p indent="1">为每个进程分配一页的内核栈  Map it high in memory, followed by an invalid guard page.</p></section>
    </article>
</main>

    </body>
</html>
