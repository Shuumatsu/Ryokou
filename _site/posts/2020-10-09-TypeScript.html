<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta http-equiv="x-ua-compatible" content="ie=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Ryokou - 2020-10-09-TypeScript</title>
        <link rel="stylesheet" href="../web/static/main.css" />
        <script src="../web/static/main.bundle.js"></script>
        <style>
            header {
                width: 100%;
            }
            nav {
                width: 100%;
            }

            header nav {
                display: flex;
                justify-content: space-between;
            }

            footer {
                width: 100%;
                text-align: center;
            }
        </style>
    </head>

    <body>
        <header>
            <nav>
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../archive.html">Archive</a>
            </nav>
        </header>

        <style>
    /* main {
        display: flex;
        flex-direction: column;
        align-items: center;
    }

    article {
        max-width: 680px;
    } */
</style>

<main role="main">
    <h1>2020-10-09-TypeScript</h1>
    <article>
        <!-- <section class="header"></section> -->
        <section><p indent="0">基于 gradual typing ( <code-snippet>any
</code-snippet> ) 以及诸如 downcasting 等原因，TypeScript 不是一个类型安全的语言：也就是说，即使通过了 type checker 也可能 TODO</p>
<p indent="1">The ability to explicitly downcast expressions is common in most typed object-oriented languages. 通常来说，downcast 会被编译为一个 dynamic check，但在 TypeScript 中无法这样做。</p>
<p indent="0">Featherweight TypeScript: core calculus covers the non-generic part of TypeScript.</p>
<p indent="0">The TypeScript type system comprises a number of advanced constructs and</p>
<p indent="0">concepts</p>
<p indent="1">These include structural type equivalence</p>
<p indent="1">types for object-based programming (as in object calculi)</p>
<p indent="1">gradual typing (in the style of Siek and Taha [14])</p>
<p indent="0">Structural typing is a way of relating types based solely on their members. Type compatibility in TypeScript is based on structural subtyping. </p>
<p indent="0">Currently, TypeScript do type inferences in the several places, for example:</p>
<p indent="1">best common type: When a type inference is made from several expressions, the types of those expressions are used to calculate a "best common type". </p>
<p indent="2">For example, having the statement  <code-snippet>let x = [0, 1, null];
</code-snippet> , the resulting inference is the union array type  <code-snippet>(number | null)[]
</code-snippet></p>
<p indent="1">contextual typing: Contextual typing occurs when the type of an expression is implied by its location. For example:</p>
<code-snippet indent="2" block="true">window.onmousedown = function (mouseEvent) {
    console.log(mouseEvent.button); //&lt;- OK
    console.log(mouseEvent.kangaroo); //&lt;- Error!
};
</code-snippet>
<p indent="0">But it's far from enough, in most cases, TypeScript will regard the unannoted terms as of type  <code-snippet>any
</code-snippet> which equals to the  <code-snippet>?
</code-snippet> in the gradual typing system.</p></section>
    </article>
</main>

    </body>
</html>
