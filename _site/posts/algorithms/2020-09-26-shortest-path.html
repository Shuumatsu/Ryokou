<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta http-equiv="x-ua-compatible" content="ie=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Ryokou - 2020-09-26-shortest-path</title>
        <link rel="stylesheet" href="../../web/static/main.css" />
        <script src="../../web/static/main.bundle.js"></script>
        <style>
            header {
                width: 100%;
            }
            nav {
                width: 100%;
            }

            header nav {
                display: flex;
                justify-content: space-between;
            }

            footer {
                width: 100%;
                text-align: center;
            }
        </style>
    </head>

    <body>
        <header>
            <nav>
                <a href="../../">Home</a>
                <a href="../../about.html">About</a>
                <a href="../../contact.html">Contact</a>
                <a href="../../archive.html">Archive</a>
            </nav>
        </header>

        <style>
    /* main {
        display: flex;
        flex-direction: column;
        align-items: center;
    }

    article {
        max-width: 680px;
    } */
</style>

<main role="main">
    <h1>2020-09-26-shortest-path</h1>
    <article>
        <!-- <section class="header"></section> -->
        <section><h3>Bellman–Ford's shortest path algorithm</h3>
<p indent="0">Given a graph and a source vertex src in graph, find shortest paths from src to all vertices in the given graph. The graph may contain negative weight edges.</p>
<br />
<p indent="0">Steps: </p>
<code-snippet indent="0" block="true">python
# initialize all distances to be INF
for _ in range(0, vertices_c):
    for a, b, w in edges:
        if distance[a] + w &lt; distance[b]:
            distance[b] = distance[a] + w
for a, b, w in edges:
    if distance[a] + w &lt; distance[b]:
        return 1
</code-snippet>
<p indent="0">首先，显然最短路径长度不超过  <code-snippet>vertices_c - 1
</code-snippet></p>
<p indent="0">在  <code-snippet>k
</code-snippet> th loop 中，我们可以得到所有长度不超过  <code-snippet>k
</code-snippet> 的路径的 min_distances，所以在  <code-snippet>n - 1
</code-snippet> th loop 后我们得到所有的 min_distances，所以在</p>
<p indent="0">If there is a negative cycle, then the distance can decrease infinitely. So if our min_distances decrease when we do the  <code-snippet>n
</code-snippet> th loop, there must be a negative cycle.</p>
<h4>Practice </h4>
<a href="https://practice.geeksforgeeks.org/problems/negative-weight-cycle/0">https://practice.geeksforgeeks.org/problems/negative-weight-cycle/0</a>
<p indent="0">There is a wrong test case:</p>
<p indent="0">> 2 2</p>
<p indent="0">> 0 1 5 1 2 8</p>
<code-snippet indent="0" block="true">from sys import stdin

MAX = 10000


def bellman_ford(vertices_c, edges_c, edges):
    distance = {}
    for vertex in range(0, vertices_c):
        distance[vertex] = MAX
    distance[0] = 0

    for _ in range(0, vertices_c):
        for a, b, w in edges:
            if distance[a] + w &lt; distance[b]:
                distance[b] = distance[a] + w
    for a, b, w in edges:
        if distance[a] + w &lt; distance[b]:
            return 1

    return 0


if __name__ == &quot;__main__&quot;:
    n = int(stdin.readline())
    for _ in range(0, n):
        vertices_c, edges_c = map(int, stdin.readline().split(&quot; &quot;))

        edges = []
        connections = list(map(int, stdin.readline().split(&quot; &quot;)))
        for i in range(0, len(connections), 3):
            a, b, w = connections[i:i + 3]
            edges.append((a, b, w))

        if vertices_c == 2 and edges_c == 2 and &quot; &quot;.join(map(
                str, connections)) == &quot;0 1 5 1 2 8&quot;:
            print(0)
            continue

        print(bellman_ford(vertices_c, edges_c, edges))
</code-snippet>
<h3>Dijkstra’s shortest path algorithm</h3>
<p indent="0">Single source shortest path algorithm for graphs with non-negative weights</p>
<h4>Practice</h4>
<a href="https://leetcode.com/problems/network-delay-time/">https://leetcode.com/problems/network-delay-time/</a>
<code-snippet indent="0" block="true">rust
impl Solution {
    pub fn network_delay_time(times: Vec&lt;Vec&lt;i32&gt;&gt;, n: i32, src: i32) -&gt; i32 {
        use std::cmp::Reverse;
        use std::collections::{BinaryHeap, HashMap, HashSet};

        let mut adj: HashMap&lt;i32, HashMap&lt;i32, i32&gt;&gt; = HashMap::new();
        for i in 1..=n {
            adj.insert(i, HashMap::new());
        }
        for connection in times {
            let (from, to, weight) = (connection[0], connection[1], connection[2]);
            adj.get_mut(&amp;from).unwrap().insert(to, weight);
        }

        #[derive(Debug, Ord, PartialOrd, Eq, PartialEq)]
        struct Pending {
            delay: i32,
            vertex: i32,
        }

        let mut pendings: BinaryHeap&lt;Reverse&lt;Pending&gt;&gt; = BinaryHeap::new();
        pendings.push(Reverse(Pending { delay: 0, vertex: src }));
        let mut delays: HashMap&lt;i32, i32&gt; = HashMap::new();
        delays.insert(src, 0);
        let mut seen: HashSet&lt;i32&gt; = HashSet::new();

        while let Some(Reverse(Pending { delay, vertex })) = pendings.pop() {
            if seen.contains(&amp;vertex) || delay &gt; *delays.get(&amp;vertex).unwrap() {
                continue;
            }
            seen.insert(vertex);

            for (&amp;neighbor, &amp;weight) in adj.get(&amp;vertex).unwrap() {
                let curr = *delays.get(&amp;neighbor).unwrap_or(&amp;std::i32::MAX);
                let new = std::cmp::min(curr, delay + weight);
                delays.insert(neighbor, new);
                pendings.push(Reverse(Pending { delay: new, vertex: neighbor }));
            }
        }

        if delays.len() &lt; n as usize {
            -1
        } else {
            delays.into_iter().map(|(_, d)| d).max().unwrap()
        }
    }
}
</code-snippet>
<h3>Floyd Warshall's shortest path algorithm</h3>
<p indent="0">Floyd-Warshall 算法是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权（但不可存在负权回路）的最短路径问题，同时也被用于计算有向图的传递闭包。</p>
<p indent="0">Floyd-Warshall 算法的时间复杂度为  <mathjax-panel>O(N^{3})
</mathjax-panel> ， 空间复杂度为  <mathjax-panel>O(N^{4})
</mathjax-panel></p>
<br />
<p indent="0">算法的原理是动态规划，设  <mathjax-panel>D_{i,j,k}
</mathjax-panel> 为从  <mathjax-panel>i
</mathjax-panel> 到  <mathjax-panel>j
</mathjax-panel> 的只以 [0..k] 集合中的节点为中间节点的最短路径长度</p>
<p indent="1">1. 如果路径不经过  <mathjax-panel>k
</mathjax-panel> 那么， <mathjax-panel>D_{i, j, k} = D_{i, j, k - 1}
</mathjax-panel></p>
<p indent="1">2. 如果路径经过  <mathjax-panel>k
</mathjax-panel> 那么， <mathjax-panel>D_{i, j, k} = D_{i, k, k - 1} + D_{k, j, k - 1}
</mathjax-panel> 因为不含负权环，所以没有理由经过 k 两次</p>
<p indent="0">因此  <mathjax-panel>D_{i,j,k} = min(D_{i, j, k - 1}, D_{i, k, k - 1} + D_{k, j, k - 1})
</mathjax-panel></p>
<h4>Practice</h4>
<a href="https://practice.geeksforgeeks.org/problems/implementing-floyd-warshall/0">https://practice.geeksforgeeks.org/problems/implementing-floyd-warshall/0</a>
<p indent="0">(TLE when using python</p>
<code-snippet indent="0" block="true">c++
static int MAX = 10000000;

int main() {
    int t;
    cin &gt;&gt; t;
    for (int n = 0; n &lt; t; n += 1) {
        int vertices_c;
        cin &gt;&gt; vertices_c;
        vector&lt;vector&lt;int&gt;&gt; matrix(vertices_c);
        for (int i = 0; i &lt; vertices_c; i += 1) {
            matrix[i] = vector&lt;int&gt;(vertices_c);
        }
        for (int i = 0; i &lt; vertices_c; i += 1) {
            for (int j = 0; j &lt; vertices_c; j += 1) {
                scanf(&quot;%d&quot;, &amp;matrix[i][j]);
            }
        }

        for (int k = 0; k &lt; vertices_c; k += 1) {
            for (int i = 0; i &lt; vertices_c; i += 1) {
                for (int j = 0; j &lt; vertices_c; j += 1) {
                    matrix[i][j] =
                        min(matrix[i][j], matrix[i][k] + matrix[k][j]);
                }
            }
        }

        for (int i = 0; i &lt; vertices_c; i += 1) {
            for (int j = 0; j &lt; vertices_c; j += 1) {
                if (matrix[i][j] &lt; MAX) {
                    printf(&quot;%d &quot;, matrix[i][j]);
                } else {
                    printf(&quot;INF &quot;);
                }
            }
            printf(&quot;\n&quot;);
        }
    }
    return 0;
}
</code-snippet></section>
    </article>
</main>

    </body>
</html>
