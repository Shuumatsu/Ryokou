自动机相关的证明常用对于串的长度的数学归纳法，并且常用某种输入对应到某种状态，而不是某种输入到接受。这样便于递归

证明两个正则表达式相等的问题的时候，**任何整体都可以看作一个符号**。比如 $R + S = S + R$ 其中大写字母都代表某个正则表达式整体，但是我们只需要证明 $r + s = s + r$ 即可（理由是3.14的定理 说实话没看懂

**从 NFA 到 DFA**：子集构造，证明采用数学归纳法

**从 DFA 到 Reg**：给每个状态编号，$R_{ijk}$ 表示中间状态最高到 $k$ 的路径的正则表示。得到转移方程 $R_{ijk} = R_{ij(k-1)} + R_{ik(k-1)}(R_{kk(k-1)})*R_{kj(k-1)}$

**从 DFA 到 Reg**：通过消除每条初始状态到某个接受状态路径上的状态来构造正则表达式（有多个接受状态的话就有多条路径，最后将每条路径对应的正则表达式合起来
每消除一个状态 $p_s$ 就为其每个前驱 $q_i$ 及每个后继 $q_j$ 添加一条 $r_{i \rightarrow s} r_{s \rightarrow s}^* r_{s \rightarrow j}$
- 消到最后剩一个开始状态和接受状态，看67页

**从 Reg 到 FA**
- 长度不大于 2 的话那么直接画
- 长度大于等于2的表达式可看作单长度的表达式经过三种运算得到的：连接、或、闭包
    1. 连接：$RS$ 用一个 $\epsilon$ 把 DFA(R) 的终态和 DFA(S) 的初态连起来
    2. 或：$R + S$ 两个 $\epsilon$ 分别转移到R、S的初态，再两个分别从 R、S 终态转移出来
    3. 闭包：$R^*$  一个 $\epsilon$ 从 R 的终转移到其始，一个 $\epsilon$ 跳过R

所以我们只需要根据运算优先级依次转化就行

**判断两个 DFA 等价**：合成一个 FA，判断初始状态是否不可区分

**Simplify**：通过分类的方式做状态化简，最开始将接收状态分为一类，然后将非接收状态分为一类。多次迭代直到没有变化
    - 判断是否同一类/可区分的时候可以用梯形图（数电里面也是，不过我还不会用这个来着，还需要再看下
  
用这个分组的方法化简下来的 DFA 一定是最小的 DFA，因为两个 DFA 是等价的，那么他们的初始状态是不可区分，不可区分的状态面对同一个输入对应的状态也是不可区分的
    那么 M 中的每一个状态（显然 M、N 中的每个状态都是可达的，不然没资格竞争最小）都在 N 中有对应的。按假设 N 有更少的状态，则根据鸽笼原理，有两个 M 中的状态对应了同一个 N。这就矛盾了

---

用 NFA 识别关键字，初始状态对所有输入都有到自己的弧，表示猜测还没有出现任何关键字的第一个字母。
这个 NFA 有一个重要的性质是，用子集构造的方式转到 DFA 并不会增加状态，每个 NFA 中的每个可达状态可以与 DFA 中的一个状态对应
假设这个可达状态 $q$ 是 $w = w_1 w_2\dots w_n$ 得到的，则对应 DFA 中的状态 (s,q,…w的后缀们可达的状态）
(已知每个状态的情况下弄子集构造比从s开始按每个输入展开省了很多计算量

<!-- 对每个关键字形如 $a_1a_2a_3\dots$ 可以从初始状态有一条串 $q_1q_2q_3\dots$ -->