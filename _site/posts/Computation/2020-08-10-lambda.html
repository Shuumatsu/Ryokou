<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta http-equiv="x-ua-compatible" content="ie=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Ryokou - 2020-08-10-lambda</title>
        <link rel="stylesheet" href="../../web/static/main.css" />
        <script src="../../web/static/main.bundle.js"></script>
        <style>
            header {
                width: 100%;
            }
            nav {
                width: 100%;
            }

            header nav {
                display: flex;
                justify-content: space-between;
            }

            footer {
                width: 100%;
                text-align: center;
            }
        </style>
    </head>

    <body>
        <header>
            <nav>
                <a href="../../">Home</a>
                <a href="../../about.html">About</a>
                <a href="../../contact.html">Contact</a>
                <a href="../../archive.html">Archive</a>
            </nav>
        </header>

        <style>
    /* main {
        display: flex;
        flex-direction: column;
        align-items: center;
    }

    article {
        max-width: 680px;
    } */
</style>

<main role="main">
    <h1>2020-08-10-lambda</h1>
    <article>
        <!-- <section class="header"></section> -->
        <section><p indent="0">bound var: a var that's associated with some  <mathjax-panel>\lambda
</mathjax-panel></p>
<p indent="0">free var: a var not associated with any  <mathjax-panel>\lambda
</mathjax-panel></p>
<p indent="1">直观上来说，如果 x is bound 则 x 在一个左边为 x 的  <mathjax-panel>\lambda
</mathjax-panel> 的子树中</p>
<p indent="0">A closed term is one in which all identifiers are bound.</p>
<br />
<p indent="0">In the pure lambda calculus, any abstraction is a value. Remember, an abstraction λx. e is a function; in the pure lambda calculus, the only values are functions. </p>
<p indent="0">In an applied lambda calculus with integers and arithmetic operations, values also include integers. Intuitively, a value is an expression that can not be reduced/executed/simplified any further.</p>
<h3>substitution</h3>
<p indent="0"><b>α-equivalence</b> : we can change the name of bound variables without changing the meaning of functions. Thus λx.x is the same function as λy.y. Expressions e1 and e2 that differ only in the name of bound variables are called α-equivalent ("alpha equivalent"), sometimes written e1 =α e2.</p>
<p indent="0"><b>β-equivalence</b> : We write e1{e2/x} to mean expression e1 with all free occurrences of x replaced with e2.</p>
<code-snippet indent="1" block="true">((λx.λy.x)y)z
        -&gt;  ((λy.x)[y/x])z   // substitute y for x in the body of &quot;λy.x&quot;
        -&gt;  ((λy'.x)[y/x])z  // after alpha reduction
        -&gt;  (λy'.y)z         // first beta-reduction complete!
        -&gt;  y[z/y']          // substitute z for y' in &quot;y&quot;
        -&gt;  y                // second beta-reduction complete!
</code-snippet>
<p indent="0">we call ((λx.λy.x)y)z and y are beta-equivalent</p>
<p indent="0">Note that the term "beta-*reduction*" is perhaps misleading, since doing beta-reduction does not always produce a smaller lambda expression. In fact, a beta-reduction can:</p>
<p indent="1">not change:  <code-snippet>(λx.xx)(λx.xx) → (λx.xx)(λx.xx)
</code-snippet></p>
<p indent="1">increase:  <code-snippet>(λx.xxx)(λx.xxx) → (λx.xxx)(λx.xxx)(λx.xxx) → (λx.xxx)(λx.xxx)(λx.xxx)(λx.xxx)
</code-snippet></p>
<p indent="1">decrease:  <code-snippet>(λx.xx)(λa.λb.bbb) → (λa.λb.bbb)(λa.λb.bbb) → λb.bbb
</code-snippet></p>
<h3>normal form</h3>
<p indent="0">We say that a lambda expression without redexes (applications of a function to an argument) is in  <b>normal form</b> , and that a lambda expression  <b>has</b> a normal form iff there is some sequence of beta-reductions and/or expansions that leads to a normal form.</p>
<p indent="0"><code-snippet>(λx.λy.y)((λz.zz)(λz.zz))
</code-snippet> . This lambda expression contains two redexes:</p>
<p indent="1">the whole expression</p>
<p indent="1">the argument itself:  <code-snippet>((λz.zz)(λz.zz))
</code-snippet></p>
<p indent="0">如果我们先对 argument 做 beta reduction 则永远不会得到 norm form 但是如果先对第一个 redex 做则可以</p>
<p indent="0"><b>leftmost-outermost</b> or  <b>normal-order-reduction (NOR)</b> 能够保证得到 norm form (如果存在的话)</p>
<p indent="0">Definition: An outermost redex is a redex that is not contained inside another one. (Similarly, an innermost redex is one that has no redexes inside it.)</p>
<p indent="0">In terms of the abstract-syntax tree, an "apply" node represents an outermost redex iff</p>
<p indent="1">it represents a redex (its left child is a lambda), and</p>
<p indent="2">it has no ancestor "apply" node in the tree that also represents a redex.</p>
<code-snippet indent="0" block="true">apply  &lt;-- not a redex
                           /     \
an outermost redex --&gt; apply      apply &lt;-- another outermost redex
                      /    \      /    \
                     λ     ...   λ      apply  &lt;-- redex, but not outermost
                    / \         / \     /   \     
                  ... ...      ... ... λ    ...
</code-snippet>
<p indent="0">If it is a function that ignores its argument, then reducing that redex can make other redexes (those that define the argument) "go away"; however, reducing an argument will never make the function "go away".</p>
<h3>Evaluation strategy</h3>
<p indent="1">call by value: leftmost-innermost (applicative-order reduction (AOR))</p>
<p indent="1">call by name: leftmost-outermost (normal-order-reduction (NOR))</p>
<p indent="1">call by need: like call by name but the result of the evaluation is saved and is then reused for each subsequent use of the formal.</p></section>
    </article>
</main>

    </body>
</html>
