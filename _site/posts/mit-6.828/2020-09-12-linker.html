<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta http-equiv="x-ua-compatible" content="ie=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Ryokou - 2020-09-12-linker</title>
        <link rel="stylesheet" href="../../web/static/main.css" />
        <script src="../../web/static/main.bundle.js"></script>
        <style>
            header {
                width: 100%;
            }
            nav {
                width: 100%;
            }

            header nav {
                display: flex;
                justify-content: space-between;
            }

            footer {
                width: 100%;
                text-align: center;
            }
        </style>
    </head>

    <body>
        <header>
            <nav>
                <a href="../../">Home</a>
                <a href="../../about.html">About</a>
                <a href="../../contact.html">Contact</a>
                <a href="../../archive.html">Archive</a>
            </nav>
        </header>

        <style>
    /* main {
        display: flex;
        flex-direction: column;
        align-items: center;
    }

    article {
        max-width: 680px;
    } */
</style>

<main role="main">
    <h1>2020-09-12-linker</h1>
    <article>
        <!-- <section class="header"></section> -->
        <section><code-snippet indent="0" block="true">src codes -- compiler --&gt; assembly code -- assembler --&gt; object file
</code-snippet>
<p indent="0">在有 shared libraries 之前，一个同时运行多个进程的系统中，几乎每个进程 had a copy of exactly the same code。Shared libraries were invented as an optimization for virtual memory systems running many processes simultaneously. </p>
<br />
<p indent="0">The linker operates on a small number of basic data types:  <b>symbols</b> ,  <b>relocations</b> , and  <b>contents</b> .</p>
<p indent="0">a linker converts object files into executables and shared libraries.</p>
<br />
<p indent="0">A symbol is basically a name and a value. For example, in an object file generated from C code, there will be a symbol for each function and for each global and static variable. </p>
<p indent="0">The value of such a symbol is simply an offset into the contents. This type of symbol is known as a defined symbol. The value of the symbol is roughly the address of the variable: the value you would get from the expression  <code-snippet>&amp;my_global_var
</code-snippet> in C.</p>
<p indent="0">Symbols are also used to indicate a reference to a name defined in a different object file. Such a reference is known as an undefined symbol.</p>
<p indent="0">During the linking process, the linker will assign an address to each defined symbol, and will resolve each undefined symbol by finding a defined symbol with the same name.</p>
<br />
<p indent="0">A relocation is a computation to perform on the contents.</p>
<p indent="0">Most relocations refer to a symbol and to an offset within the contents.</p>
<p indent="0">A relocation in an object file may refer to an undefined symbol. If the linker is unable to resolve that symbol, it will normally issue an error.</p>
<br />
<p indent="0">The contents are what memory should look like during the execution of the program. Contents have a size, an array of bytes, and a type. They contain</p>
<p indent="1">- the machine code generated by the compiler and assembler (known as text). </p>
<p indent="1">- the values of initialized variables (data).</p>
<p indent="1">- static unnamed data like string constants and switch tables (read-only data or rdata). </p>
<p indent="1">- uninitialized variables, in which case the array of bytes is generally omitted and assumed to contain only zeroes (bss).</p>
<p indent="0">The linker reads the contents from each file, concatenates them all together sorted by type, applies the relocations, and writes the result into the executable file.</p>
<br />
<p indent="0">Basic Linker Operation</p>
<p indent="1">- Read the input object files. Determine the length and type of the contents. Read the symbols.</p>
<p indent="1">- Build a symbol table containing all the symbols, linking undefined symbols to their definitions.</p>
<p indent="1">- Decide where all the contents should go in the output executable file, which means deciding where they should go in memory when the program runs.</p>
<p indent="1">- Read the contents data and the relocations. Apply the relocations to the contents. Write the result to the output file.</p>
<p indent="1">- Optionally write out the complete symbol table with the final values of the symbols.</p>
<br />
<p indent="0">An  <b>address space</b> is simply a view of memory, in which each byte has an address. The linker deals with three distinct types of address space.</p>
<p indent="0">Every input object file is a small address space: the contents have addresses, and the symbols and relocations refer to the contents by addresses.</p>
<p indent="0">The output program will be placed at some location in memory when it runs. This is the output address space or  <b>virtual memory addresses</b> .</p>
<p indent="0">The output program will be loaded at some location in memory. This is the  <b>load memory address</b> .</p>
<br />
<p indent="0">System components that take part in managing a process's memory:</p>
<p indent="1">- Compiler and assembler:</p>
<p indent="2">- Generate one  <b>object file</b> for each source code file containing information for that source file.</p>
<p indent="2">- Information is incomplete, since each source file generally references some things defined in other source files.</p>
<p indent="1">- Linker:</p>
<p indent="2">- Combines all of the object files for one program into a single object file.</p>
<p indent="2">- Linker output is complete and self-sufficient.</p>
<p indent="1">- Operating system:</p>
<p indent="2">- Loads object files into memory.</p>
<p indent="2">- Allows several different processes to share memory at once.</p>
<p indent="2">- Provides facilities for processes to get more memory after they've started running.</p>
<p indent="1">- Run-time library:</p>
<p indent="2">- Works together with OS to provide dynamic allocation routines, such as  <code-snippet>malloc
</code-snippet> and  <code-snippet>free
</code-snippet> in C.</p>
<p indent="0">Linkers (or Linkage Editors, ld in Unix, LINK on Windows): combine many separate pieces of a program, re-organize storage allocation. Typically invoked invisibly by compilers.</p>
<p indent="0">Three functions of a linker:</p>
<p indent="1">- Collect all the pieces of a program.</p>
<p indent="1">- Figure out a new memory organization so that all the pieces fit together (combine like sections)</p>
<p indent="1">- Touch up addresses so that the program can run under the new memory organization.</p>
<p indent="0">Problems linker must solve:</p>
<p indent="1">- Assembler doesn't know addresses of external objects when assembling files separately.</p>
<p indent="1">- Assembler doesn't know where the things it's assembling will go in memory</p>
<p indent="2">- Assume that things start at address zero, let linker re-arrange.</p>
<br />
<p indent="0">Relocation records : information about addresses referenced in this object file that the linker must adjust once it knows the final memory allocation.</p>
<p indent="0">Linker executes in two passes:</p>
<p indent="1">- 1. read in section sizes, compute final memory layout. Also, read in all symbols, create complete symbol table in memory.</p>
<p indent="1">- 2. read in section and relocation information, update addresses, write out new file.</p>
<h3>Dynamic Linking</h3>
<p indent="0">Originally all programs were linked statically:</p>
<p indent="1">- All external references fully resolved</p>
<p indent="1">- Each program complete</p>
<p indent="0">most systems have supported shared libraries and dynamic linking:</p>
<p indent="1">- For common library packages, only keep a single copy in memory, shared by all processes.</p>
<p indent="1">- Don't know where library is loaded until runtime; must resolve references dynamically, when program runs.</p>
<p indent="0">One way of implementing dynamic linking: jump table</p>
<p indent="1">- If any of the files being linked are shared libraries, the linker doesn't actually include the shared library code in the final program. Instead, it includes two things that implement dynamic linking:</p>
<p indent="2">- Jump table: an array in which each entry is a single machine instruction containing an unconditional branch (jump)</p>
<p indent="3">- For each function in a shared library used by the program, there is one entry in the jump table that will jump to the beginning of that function.</p>
<p indent="3">- Dynamic loader: library package invoked at startup to fill in the jump table.</p>
<p indent="1">- For relocation records referring to functions in the shared library, the linker substitutes the address of the jump table entry: when the function is invoked, the caller will "call" the jump table entry, which redirects the call to the real function.</p>
<p indent="1">- Initially, all jump table entries jump to zero (unresolved).</p>
<p indent="1">- When the program starts up, the dynamic load library is invoked:</p>
<p indent="2">- It invokes the OS mmap functions to load each shared library into memory.</p>
<p indent="2">- It fills in the jump table with the correct address for each function in a shared library.</p></section>
    </article>
</main>

    </body>
</html>
