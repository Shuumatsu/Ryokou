<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta http-equiv="x-ua-compatible" content="ie=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Ryokou - 2020-09-26-lazy-evaluation</title>
        <link rel="stylesheet" href="../web/static/main.css" />
        <script src="../web/static/main.bundle.js"></script>
        <style>
            header {
                width: 100%;
            }
            nav {
                width: 100%;
            }

            header nav {
                display: flex;
                justify-content: space-between;
            }

            footer {
                width: 100%;
                text-align: center;
            }
        </style>
    </head>

    <body>
        <header>
            <nav>
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../archive.html">Archive</a>
            </nav>
        </header>

        <style>
    /* main {
        display: flex;
        flex-direction: column;
        align-items: center;
    }

    article {
        max-width: 680px;
    } */
</style>

<main role="main">
    <h1>2020-09-26-lazy-evaluation</h1>
    <article>
        <!-- <section class="header"></section> -->
        <section><p indent="0">通过 list map 理解 lazy evaluation:</p>
<code-snippet indent="0" block="true">xs = [1,2,3,4,5,6,7,8]
map f $ map f xs
</code-snippet>
<p indent="0">上面的代码对每个元素执行了两次  <code-snippet>f
</code-snippet> 而只需要遍历一次</p>
<br />
<p indent="0">---</p>
<br />
<p indent="0">以 OCaml 为例，OCaml 是默认严格求值的语言所以不能像 Haskell 中那样定义一个无限列表（在这里我们假装 OCaml 没有 lazy 关键字）</p>
<br />
<p indent="0">惰性求值本质上就是一个  <code-snippet>thunk
</code-snippet> ，所以我们定一个  <code-snippet>thunk
</code-snippet> 类型：</p>
<code-snippet indent="0" block="true">type 'a thunk = Evaluated of 'a | Unevaluated of (unit -&gt; 'a)

type 'a thunk_ref = 'a thunk ref

(* 从 Unevaluated 到 Evaluated *)
let force thunk_ref =
  match !thunk_ref with
  | Evaluated x -&gt;
      x
  | Unevaluated f -&gt;
      let ret = f () in
      thunk_ref := Evaluated ret ;
      ret

let thunk_from f = ref (Unevaluated f)
(* 这部分可以参考 http://typeocaml.com/2014/11/13/magic-of-thunk-lazy/ *)
</code-snippet>
<p indent="0">定义一个 stream 类型，对应 Haskell 中的列表：</p>
<code-snippet indent="0" block="true">type 'a stream = 'a _stream thunk_ref

and 'a _stream = Cons of 'a thunk_ref * 'a stream | Empty
</code-snippet>
<p indent="0">整个 stream 是惰性的，并且它的每一个元素也是惰性的。</p>
<br />
<p indent="0">惰性求值的情况下，每次  <code-snippet>map
</code-snippet> 不需要等上一次  <code-snippet>map
</code-snippet> 的遍历结束，而是总共只需要一次遍历。</p>
<br />
<p indent="0">首先我们定义  <code-snippet>head
</code-snippet> 和  <code-snippet>tail
</code-snippet> ：（实现  <code-snippet>map
</code-snippet> 需要</p>
<code-snippet indent="0" block="true">let head (stream : 'a stream) : 'a thunk_ref thunk_ref =
  thunk_from (fun () -&gt; match force stream with Cons (h, _) -&gt; h)

let tail (stream : 'a stream) : 'a stream thunk_ref =
  thunk_from (fun () -&gt; match force stream with Cons (_, t) -&gt; t)
</code-snippet>
<p indent="0">然后是 map：</p>
<code-snippet indent="0" block="true">let rec map (f : 'a -&gt; 'b) (stream : 'a stream) =
  thunk_from (fun () -&gt;
      match force stream with
      | Cons _ -&gt;
          let h = force (head stream) and t = force (tail stream) in
          Cons (thunk_from (fun () -&gt; f (force h)), map f t)
      | _ -&gt;
          Empty)
</code-snippet>
<p indent="0">（注意我们的  <code-snippet>head
</code-snippet> ,  <code-snippet>tail
</code-snippet> 以及  <code-snippet>map
</code-snippet> 方法都是由  <code-snippet>thunk_from
</code-snippet> 开头，代表他们是惰性的</p>
<br />
<p indent="0">现在我们已经做完所有的准备工作，可以验证为什么只需要一次遍历了：</p>
<code-snippet indent="0" block="true">let rec make () =
  thunk_from (fun () -&gt; Cons (thunk_from (fun () -&gt; ()), make ()))

let example = make ()

let f () = print_endline &quot;f&quot;

let g () = print_endline &quot;g&quot;

let r = example |&gt; map f |&gt; map g

let rec take_to_list (n : int) (stream : 'a stream) =
  match force stream with
  | Cons _ when n &gt; 0 -&gt;
      let h = force (head stream) and t = force (tail stream) in
      force h :: take_to_list (n - 1) t
  | _ -&gt;
      []

;;
take_to_list 2 r
(* 运行这个代码会得到输出 `fgfg` *)
</code-snippet>
<p indent="0"><code-snippet>make
</code-snippet> 返回一个无限长的  <code-snippet>stream
</code-snippet> ， 如果做不到一次遍历的话，那  <code-snippet>g
</code-snippet> 将永远得不到调用，我们也无法通过  <code-snippet>take_to_list 2 r
</code-snippet> 得到前两个元素。</p></section>
    </article>
</main>

    </body>
</html>
