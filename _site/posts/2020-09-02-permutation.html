<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta http-equiv="x-ua-compatible" content="ie=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Ryokou - 2020-09-02-permutation</title>
        <link rel="stylesheet" href="../web/static/main.css" />
        <script src="../web/static/main.bundle.js"></script>
        <style>
            header {
                width: 100%;
            }
            nav {
                width: 100%;
            }

            header nav {
                display: flex;
                justify-content: space-between;
            }

            footer {
                width: 100%;
                text-align: center;
            }
        </style>
    </head>

    <body>
        <header>
            <nav>
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../archive.html">Archive</a>
            </nav>
        </header>

        <style>
    /* main {
        display: flex;
        flex-direction: column;
        align-items: center;
    }

    article {
        max-width: 680px;
    } */
</style>

<main role="main">
    <h1>2020-09-02-permutation</h1>
    <article>
        <!-- <section class="header"></section> -->
        <section><h3>Permutations</h3>
<p indent="0">给定一个无重复数字的序列，返回这些数所能排列出所有序列。</p>
<a href="https://leetcode.com/problems/permutations/#/description">https://leetcode.com/problems/permutations/#/description</a>
<p indent="0">每次从剩下的元素中选择一个元素，然后重复这个过程，直到没有元素剩下。</p>
<p indent="0">要满足已选择的元素在接下来的过程中不再出现，比起 naive 的直接从数组中删除这个元素的做法，更好的做法是将整个数组分为左右两个区域，分别代表已选择的和未选择的，当未选择区域为空时将当前排列加入结果。每次选择的时候，未选择区最左边的位置将属于已选择区，我们的做法是将选择的元素交换至该位置</p>
<code-snippet indent="0" block="true">const permute = nums =&gt; {
    const ret = []
    const h = pos =&gt; {
        if (pos == nums.length) {
            ret.push([...nums])
            return
        }

        for (let selection = pos; selection &lt; nums.length; selection++) {
            ;[nums[pos], nums[selection]] = [nums[selection], nums[pos]]
            h(pos + 1)
            ;[nums[pos], nums[selection]] = [nums[selection], nums[pos]]
        }
    }
    h(0)

    return ret
}
</code-snippet>
<h3>Permutations II</h3>
<p indent="0">给定一个含有重复数字的序列，返回这些数所能排列出的所有不同的序列。</p>
<a href="https://leetcode.com/problems/permutations-ii/#/description">https://leetcode.com/problems/permutations-ii/#/description</a>
<p indent="0">剪枝即可，在选取元素的那层循环中，如果遇到已选择过的元素，跳过即可。</p>
<code-snippet indent="0" block="true">const permuteUnique = nums =&gt; {
    const ret = []
    const h = pos =&gt; {
        if (pos == nums.length) {
            ret.push([...nums])
            return
        }

        const seen = {}
        for (let selection = pos; selection &lt; nums.length; selection++) {
            if (seen[nums[selection]]) continue
            seen[nums[selection]] = true
            ;[nums[pos], nums[selection]] = [nums[selection], nums[pos]]
            h(pos + 1)
            ;[nums[pos], nums[selection]] = [nums[selection], nums[pos]]
        }
    }
    h(0)

    return ret
}
</code-snippet>
<h3>Next Permutation</h3>
<p indent="0">给定任一非空正整数序列，生成这些数所能排列出的下一个较大序列。若给出的序列为最大序列，则生成最小序列。</p>
<a href="https://leetcode.com/problems/next-permutation/#/description">https://leetcode.com/problems/next-permutation/#/description</a>
<p indent="0">从最右方开始寻找，一直到左直到遇到第一个元素  <code-snippet>x
</code-snippet> 它小于其右侧的元素。</p>
<p indent="0">这说明  <code-snippet>x
</code-snippet> 右侧的元素达到了其所能达到的最大值，则  <code-snippet>x
</code-snippet> 所在位置应该更新位一个更大的值。</p>
<p indent="0">在  <code-snippet>x
</code-snippet> 右侧找到最小的大于  <code-snippet>x
</code-snippet> 的元素  <code-snippet>y
</code-snippet> 。交换  <code-snippet>x
</code-snippet> 与  <code-snippet>y
</code-snippet> 的位置，并将右侧的元素以递增排列（在这里其实就是  <code-snippet>reverse
</code-snippet> 这部分</p>
<p indent="0">如果没有这样的元素，说明原序列从右到左是一个递增序列，则返回从小到大排序的序列。（在这里其实就是  <code-snippet>reverse
</code-snippet> 整个数组</p>
<code-snippet indent="0" block="true">const reverse = (nums, i, j) =&gt; {
    while (i &lt; j) {
        ;[nums[i], nums[j]] = [nums[j], nums[i]]
        i++
        j--
    }
}

/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
const nextPermutation = nums =&gt; {
    if (nums.length &lt;= 1) return

    let i = nums.length - 2
    for (; i &gt;= 0; i -= 1) {
        if (nums[i] &lt; nums[i + 1]) {
            break
        }
    }
    if (i &lt; 0) {
        reverse(nums, 0, nums.length - 1)
        return
    }

    // 因为右侧的序列是单调的，这里可以用二分搜索优化
    let j = nums.length - 1
    for (; j &gt; i - 1; j -= 1) {
        if (nums[i] &lt; nums[j]) {
            break
        }
    }
    ;[nums[i], nums[j]] = [nums[j], nums[i]]

    reverse(nums, i + 1, nums.length - 1)
}
</code-snippet>
<h3>Permutation Sequence</h3>
<p indent="0">给定正整数  <code-snippet>n
</code-snippet> 和  <code-snippet>k
</code-snippet> ，要求返回在  <code-snippet>[1, 2, ..., n]
</code-snippet> 所有的全排列中，第 k 大的字符串序列。</p>
<a href="https://leetcode.com/problems/permutation-sequence/#/description">https://leetcode.com/problems/permutation-sequence/#/description</a>
<p indent="0">为方便，将  <code-snippet>k
</code-snippet> 改作 0-based</p>
<p indent="0">根据排列数公式，我们可以知道对于每个  <code-snippet>n
</code-snippet> 总共有多少种排列  <code-snippet>A(n)
</code-snippet> ，并且有  <code-snippet>A(n) = n * A(n - 1)
</code-snippet> 。那么根据模  <code-snippet>A(n - 1)
</code-snippet> 的值可以知道当前位于  <code-snippet>n
</code-snippet> 的第几个最高位对应的那些序列中</p>
<p indent="0">采取递归的算法，从最高位到最低位考虑每一位。维护一个有序数组记录待定元素。</p>
<p indent="1">用  <code-snippet>Math.floor(k / A[arr.length - 1])
</code-snippet> 得到当前应选的元素在待定元素数组的下标 </p>
<p indent="1">用  <code-snippet>k % A[arr.length - 1]
</code-snippet> 得到下一轮递归的  <code-snippet>k
</code-snippet></p>
<code-snippet indent="0" block="true">/**
 * @param {number} n
 * @param {number} k
 * @return {string}
 */
const getPermutation = (n, k) =&gt; {
    const dp = [0, 1]
    for (let i = 2; i &lt;= n; i += 1) {
        dp[i] = dp[i - 1] * i
    }

    const f = (arr, k) =&gt; {
        if (arr.length == 1) return arr
        const nk = k % dp[arr.length - 1]
        const p = Math.floor(k / dp[arr.length - 1])
        return [arr[p], ...f([...arr.slice(0, p), ...arr.slice(p + 1)], nk)]
    }

    const arr = []
    for (let i = 1; i &lt;= n; i += 1) {
        arr.push(i)
    }
    return f(arr, (k - 1) % dp[n]).join('')
}
</code-snippet></section>
    </article>
</main>

    </body>
</html>
