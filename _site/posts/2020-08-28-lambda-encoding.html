<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta http-equiv="x-ua-compatible" content="ie=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Ryokou - 2020-08-28-lambda-encoding</title>
        <link rel="stylesheet" href="../web/static/main.css" />
        <script src="../web/static/main.bundle.js"></script>
        <style>
            header {
                width: 100%;
            }
            nav {
                width: 100%;
            }

            header nav {
                display: flex;
                justify-content: space-between;
            }

            footer {
                width: 100%;
                text-align: center;
            }
        </style>
    </head>

    <body>
        <header>
            <nav>
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../archive.html">Archive</a>
            </nav>
        </header>

        <style>
    /* main {
        display: flex;
        flex-direction: column;
        align-items: center;
    }

    article {
        max-width: 680px;
    } */
</style>

<main role="main">
    <h1>2020-08-28-lambda-encoding</h1>
    <article>
        <!-- <section class="header"></section> -->
        <section><h3>Encoding Boolean</h3>
<p indent="0"><code-snippet>let cond p a b = if p then a else b
</code-snippet> 是常见的 boolean 操作，我们从这个方法下手。可以看出如果将  <code-snippet>a b
</code-snippet> 看作一个 tuple 那么  <code-snippet>p
</code-snippet> 就像一个一个从 tuple 中取值的函数。 <code-snippet>true
</code-snippet> 为取第一个元素， <code-snippet>false
</code-snippet> 为第二个。</p>
<p indent="0">容易写出函数表达的 boolean:</p>
<code-snippet indent="0" block="true">let true' a b = a

let false' a b = b

let and' a b = a b false'

let or' a b = a true' b
</code-snippet>
<code-snippet indent="0" block="true">COND == λp.λa.λb.p a b
TRUE == λx.λy.x
FALSE == λx.λy.y

AND == λa.λb.a b FALSE
OR == λa.λb.a TRUE b
</code-snippet>
<h3>Encoding LISP-style lists</h3>
<p indent="0">从  <code-snippet>car
</code-snippet> 与  <code-snippet>cdr
</code-snippet> 入手，The way we'll define a non-nil list is as a function that "stores" the head and tail of the list in its body. Its argument will be a selector function (head or tail). </p>
<code-snippet indent="0" block="true">&lt;!-- type list = λs.s h t --&gt;
car = λl.l (λh.λt.h) = λl.l true
cdr = λl.l (λh.λt.t) = λl.l false

is_empty = λl.l (λh.λt.false)
nil = λs.true

CONS = λh.λt.(λs.s h t)
</code-snippet>
<h3>Encoding Natural Numbers</h3>
<h4>可以用 list 来实现</h4>
<code-snippet indent="0" block="true">ISZERO == ISEMPTY
PRED == TAIL
SUCC is a function that adds one more element onto a given list, so: SUCC == λL.CONS x L
</code-snippet>
<h4>根据函数 apply 的次数来实现 </h4>
<code-snippet indent="0" block="true">n = λx.λy.x^n y

0	==	λx.λy.y
1	==	λx.λy.xy
2	==	λx.λy.x(xy)
3	==	λx.λy.x(x(xy))
etc.
</code-snippet>
<code-snippet indent="0" block="true">ISZERO = λf.f(λx.FALSE)TRUE
n != 0 即 x 一旦 apply 就返回 falses，那么 let `x` be `λx.FALSE`
n == 0 即 y 直接返回就返回 true，那么 let `y` be `True`
</code-snippet>
<mathjax-panel indent="0" block="true">\left(\operatorname{SUCC}\left(\lambda x . \lambda y . x^{n} y\right)\right) \rightarrow_\beta \left(\lambda x . \lambda y . x^{n+1} y\right)
</mathjax-panel>
<p indent="0">那么需要接受一个数返回另一个数，即接受一个接受两个参数的函数返回一个接受两个参数的函数。区别在于第二个函数的第一个参数多 apply 一次，但是我们无法改变参数函数的 function body，不妨在 apply 到函数之前，先让 x apply y 一次。</p>
<p indent="0"><code-snippet>SUCC == λa.(λx.λy.a x (xy))
</code-snippet></p>
<code-snippet indent="0" block="true">module type ChurchNumber = sig
  (* in untyped lambda calculus, we can use a generic type instead of bool *)
  (* we use bool here because of is_zero *)
  type t = (bool -&gt; bool) -&gt; bool -&gt; bool

  val zero : t

  val one : t

  val two : t

  val is_zero : t -&gt; bool

  val add : t -&gt; t -&gt; t

  val mult : t -&gt; t -&gt; t
end

module ChurchNumber : ChurchNumber = struct
  type t = (bool -&gt; bool) -&gt; bool -&gt; bool

  let zero f b = b

  let one f b = f (f b)

  let two f b = f (f (f b))

  let is_zero n = n (fun _ -&gt; false) true

  let add x y f b = x f (y f b)

  let mult x y f b = x (y f) b
end
</code-snippet></section>
    </article>
</main>

    </body>
</html>
