我们从 Simply Typed Lambda Calculus 开始，Every term is explicitly typed and no type inference is performed
is strongly normalizing: evaluation terminates for any term, independent of the evaluation strategy.





We write α ::∗ to indicate that α is
a base type, and x::t to indicate that x is a term of type t.

我们用::↓表示 the type checking algorithm 的输入类型，用 ::↑ 表示输出类型

check annotated terms against their type annotation，然后返回其类型 ANN 
- （即输入输出类型相同
通过查看 environment 确定变量的类型
对于 application，我们先处理 the function 得到一个 function type，然后检查参数  against the function’s domain，最后返回 range 作为结果类型

is not polymorphic: a type identifier represents one specific type and cannot be instantiated.

locally nameless representation

We represent locally bound variables by de Bruijn indices
For example, we can write id as λ → 0, and const as λ → λ → 1
- 这种表示的优势是我们永远不需要重命名一个变量， i.e., α-equality
of terms reduces to syntactic equality of terms
- 劣势是 cumbersome to manipulate e terms with free variables 



我们用 absolute references 表示 free variables，

we use higher-order abstract syntax to represent values: values that are functions are represented using Haskell functions.

Separating inferable and checkable terms