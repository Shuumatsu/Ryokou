<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta http-equiv="x-ua-compatible" content="ie=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Ryokou - 2020-10-12-Static Analysis</title>
        <link rel="stylesheet" href="../web/static/main.css" />
        <script src="../web/static/main.bundle.js"></script>
        <style>
            header {
                width: 100%;
            }
            nav {
                width: 100%;
            }

            header nav {
                display: flex;
                justify-content: space-between;
            }

            footer {
                width: 100%;
                text-align: center;
            }
        </style>
    </head>

    <body>
        <header>
            <nav>
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../archive.html">Archive</a>
            </nav>
        </header>

        <style>
    /* main {
        display: flex;
        flex-direction: column;
        align-items: center;
    }

    article {
        max-width: 680px;
    } */
</style>

<main role="main">
    <h1>2020-10-12-Static Analysis</h1>
    <article>
        <!-- <section class="header"></section> -->
        <section><p indent="0">大多数情况下，optimization application 都需要一个 conservative approximations. 如果我们拿到了错误的信息，那么我们的优化就可能是 unsound，并且会影响到程序本来的语义。</p>
<p indent="0">一个 canonical choice 是为每个名为  <mathjax-panel>id
</mathjax-panel> 的变量 introduce a target  <mathjax-panel>&amp;id
</mathjax-panel></p>
<p indent="0">为每个 allocation site introduce a target  <mathjax-panel>malloc_i
</mathjax-panel> 其中 i 是一个唯一的 index</p>
<p indent="0">points to analysis 发生在 syntax tree 上，因为发生在 control flow analysis 之前或同时进行。</p>
<p indent="0">points to analysis 的结果是一个函数  <mathjax-panel>pt(pointer)
</mathjax-panel> 返回 set of possible pointer targets。 如果我们想知道两个指针  <mathjax-panel>p
</mathjax-panel> &  <mathjax-panel>q
</mathjax-panel> 是否可能是  aliases，那么一个安全的做法就是比较其交集  <mathjax-panel>p t(p) \cap p t(q)
</mathjax-panel></p>
<h4>Andersen’s Algorithm</h4>
<p indent="0">对每个 variable named  <mathjax-panel>id
</mathjax-panel> ，用集合  <mathjax-panel>\llbracket id \rrbracket
</mathjax-panel> 表示所有可能的 pointer targets</p>
<p indent="0">分析假设程序已经倍 normalized，也就是说 pointer manipulation 仅限于以下几种</p>
<div indent="1"><p indent="0">1)  <mathjax-panel>id = malloc
</mathjax-panel> ，生成 constraints:  <mathjax-panel>\{\mathrm{malloc_i}\} \subseteq \llbracket id \rrbracket
</mathjax-panel></p>
<p indent="0">2)  <mathjax-panel>id_1 = &amp;id_2
</mathjax-panel> ，生成 constraints:  <mathjax-panel>\left\{\&amp; i d_{2}\right\} \subseteq \llbracket i d_{1} \rrbracket
</mathjax-panel></p>
<p indent="0">3)  <mathjax-panel>id_1 = id_2
</mathjax-panel> ，生成 constraints:  <mathjax-panel>\llbracket i d_{2} \rrbracket \subseteq \llbracket i d_{1} \rrbracket
</mathjax-panel></p>
<p indent="0">4)  <mathjax-panel>id_1 = *id_2
</mathjax-panel> ，生成 constraints:  <mathjax-panel>\&amp; i d \in \llbracket i d_{2} \rrbracket \Rightarrow \llbracket i d \rrbracket \subseteq \llbracket i d_{1} \rrbracket
</mathjax-panel></p>
<p indent="0">5)  <mathjax-panel>*id_1 = id_2
</mathjax-panel> ，生成 constraints:  <mathjax-panel>\&amp; i d \in \llbracket i d_{1} \rrbracket \Rightarrow \llbracket i d_{2} \rrbracket \subseteq \llbracket i d \rrbracket
</mathjax-panel></p>
<p indent="0">6)  <mathjax-panel>id = null
</mathjax-panel> ，生成 constraints:  <mathjax-panel>\emptyset \subseteq \llbracket i d \rrbracket
</mathjax-panel> which 可以安全的被忽略</p></div>
<p indent="0">最后我们得到 5 种 constraints，最后解这些约束就得到算法的结果</p>
<h4>Steensgaard’s Algorithm</h4>
<p indent="0">另一个更粗略度一点的算法，by viewing assignments as being bidirectional.</p>
<p indent="0">TODO</p>
<p indent="0">解这些约束就得到算法的结果，The resulting points-to function is defined as:</p>
<mathjax-panel indent="0" block="true">pt(p)=\{\&amp; id \mid * p \sim id \} \cup \{ malloc_i \mid * p \sim malloc_i \}
</mathjax-panel>
<h3>Interprocedural Points-To Analysis</h3>
<p indent="0">函数指针也可能有 indirect references，我们需要同时做 control flow analysis and the points-to analysis。例如： <code-snippet>(***x)(1,2,3);
</code-snippet></p>
<p indent="0">我们可以对程序做一个简化，使得 function calls 总是形如  <code-snippet>id1 = (id2)(a1, ..., an);
</code-snippet> 。类似的 all return expressions are assumed to be just variables.</p>
<p indent="0">到目前为止我们都只是把 heap 看作一个 amorphous 结构，几乎只关注了 stack based vars. 我们可以用 shape analysis 对堆进行更细致的分析。</p>
<p indent="0">Shape graphs 是一个有向图，其每一个节点都是一个 pointer targets。Shape graphs 的 order 根据 inclusion of their sets of edges 定义。Thus,  <mathjax-panel>\perp
</mathjax-panel> is the graph without edges and  <mathjax-panel>\top
</mathjax-panel> is the completely connected graph.</p>
<p indent="0">pointer targets 表示在执行期间可能创建的 memory cells，边表示两个 cell 间可能包含一个引用。</p></section>
    </article>
</main>

    </body>
</html>
