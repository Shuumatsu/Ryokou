保证正确的关键是确定，关键的控制逻辑的变量、语句只有目标线程在目标时刻操作

比如某个锁应在某对人（这里两个人看作两个线程）进场跳舞后解锁，那我们应该明确，这个情况下
    \- 解锁应在两个人都进场跳舞后
    \- 应该由参与工作的线程解锁，并且只应解锁一次

所以我们的代码可以是

```rust
fn thread_a() {
    dance();
    rendezvous.signal()
}

fn thread_b() {
    dance();
    rendezvous.wait()
    mutex_t.signal()
}
```

首先我们有一个目标锁 `mutex_t`。我们需要一个 `rendezvous` 变量记录是否两人都已进场跳舞，以便实现两人都进场后解锁这一逻辑。

就要求上来说 `mutex_t` 由任何一个线程来解锁都是可以的，但通常固定某个线程解锁是一个更简单的选择，并且不会有性能损失。不失一般性的，这里我们选择 `thread_b`。

就逻辑上来说，`rendezvous` 条件在后一个人进场跳舞后满足。最直接的考虑方法是记录进场顺序或用一个计数器记录进场人数，满足条件后由最后一个线程解锁，更简单的方法是，基于与 `mutex_t` 同样的理由，固定某个线程解锁。
 