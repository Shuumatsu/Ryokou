基于 gradual typing (`any`) 以及诸如 downcasting 等原因，TypeScript 不是一个类型安全的语言：也就是说，即使通过了 type checker 也可能 TODO
- The ability to explicitly downcast expressions is common in most typed object-oriented languages. 通常来说，downcast 会被编译为一个 dynamic check，但在 TypeScript 中无法这样做。

Featherweight TypeScript: core calculus covers the non-generic part of TypeScript.


The TypeScript type system comprises a number of advanced constructs and
concepts
- These include structural type equivalence
- types for object-based programming (as in object calculi)
- gradual typing (in the style of Siek and Taha [14])


Structural typing is a way of relating types based solely on their members. Type compatibility in TypeScript is based on structural subtyping. 


Currently, TypeScript do type inferences in the several places, for example:
- best common type: When a type inference is made from several expressions, the types of those expressions are used to calculate a "best common type". 
-- For example, having the statement `let x = [0, 1, null];`, the resulting inference is the union array type `(number | null)[]`
- contextual typing: Contextual typing occurs when the type of an expression is implied by its location. For example:
-- ```
window.onmousedown = function (mouseEvent) {
    console.log(mouseEvent.button); //<- OK
    console.log(mouseEvent.kangaroo); //<- Error!
};
```
But it's far from enough, in most cases, TypeScript will regard the unannoted terms as of type `any` which equals to the `?` in the gradual typing system.