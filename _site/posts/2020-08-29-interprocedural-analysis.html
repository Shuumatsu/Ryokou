<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta http-equiv="x-ua-compatible" content="ie=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Ryokou - 2020-08-29-interprocedural-analysis</title>
        <link rel="stylesheet" href="../web/static/main.css" />
        <script src="../web/static/main.bundle.js"></script>
        <style>
            header {
                width: 100%;
            }
            nav {
                width: 100%;
            }

            header nav {
                display: flex;
                justify-content: space-between;
            }

            footer {
                width: 100%;
                text-align: center;
            }
        </style>
    </head>

    <body>
        <header>
            <nav>
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../archive.html">Archive</a>
            </nav>
        </header>

        <style>
    /* main {
        display: flex;
        flex-direction: column;
        align-items: center;
    }

    article {
        max-width: 680px;
    } */
</style>

<main role="main">
    <h1>2020-08-29-interprocedural-analysis</h1>
    <article>
        <!-- <section class="header"></section> -->
        <section><p indent="0"><b>propagate data-flow information along interprocedural control-flow edges</b></p>
<p indent="1">(i.e., call and return edges</p>
<h3>Call Graph Construction (CHA)</h3>
<p indent="0">Definition: a call graph is a set of call edges from call-sites to their target methods (callees)</p>
<h4>Method Calls (Invocations) in Java</h4>
<ul><li>static call: invokestatic</li>
<p indent="1">- target methods: static methods</p>
<p indent="1">- # target methods: 1</p>
<p indent="1">- determinacy: compile-time</p>
<li>special call: invokespecial </li>
<p indent="1">- target methods: constructors; private instance methods; superclass instance methods</p>
<p indent="1">- # target methods: 1</p>
<p indent="1">- determinacy: compile-time</p>
<li>virtual call: invokeinterface; invokevirtual </li>
<p indent="1">- target methods: other instance methods</p>
<p indent="1">- # target methods: >= 1</p>
<p indent="1">- determinacy: runtime</p></ul>
<p indent="0">During run-time, a virtual call is resolved based on</p>
<p indent="1">1. type of the receiver object:  <code-snippet>c</code-snippet></p>
<p indent="1">2. method signature at the call site:  <code-snippet>m</code-snippet></p>
<p indent="2">(signature = class type + method name + descriptor</p>
<p indent="2">(descriptor = return type + parameter types</p>
<p indent="0">We define a function  <code-snippet>dispatch(c, m)</code-snippet> to simulate the procedure of run-time method dispatch</p>
<p indent="1">-  <code-snippet>m'</code-snippet> : if  <code-snippet>c</code-snippet> contains non-abstract method  <code-snippet>m'</code-snippet> that has the same name and descriptor</p>
<p indent="1">-  <code-snippet>dispatch(c', m)</code-snippet> where  <code-snippet>c'</code-snippet> is a superclass of  <code-snippet>c</code-snippet> : otherwise</p>
<p indent="0">e.g. consider  <code-snippet>dispatch(B, A.foo)</code-snippet> with the following classes.</p>
<code-snippet indent="0" block="true">class A { void foo() {} }
class B extends A {}
</code-snippet>
<p indent="0">here  <code-snippet>A.</code-snippet> is not considered according to rule 1. and B has no mathed method, so we go to its superclass  <code-snippet>dispatch(A, A.foo()) == A.foo()</code-snippet></p>
<h4>Call Resolution of CHA</h4>
<p indent="0">Resolve a virtual call based on the declared type of receiver variable of the call site  <code-snippet>A a = ...; a.foo();</code-snippet></p>
<p indent="1">the receiver variable a may point to objects of class  <code-snippet>A</code-snippet> and all subclasses of  <code-snippet>A</code-snippet></p>
<code-snippet indent="0" block="true">resolve(cs) // I think it's call site...
    m = method signature at cs 
    if cs is a static call then:
        return {m}
    else if cs is a special call then:
        cm = class type of m
        return {dispatch(cm, m)}
    else: 
        c = declared type of receiver 
        return $ fmap (fun c' -&gt; dispatch c' m) all_subclasses
</code-snippet>
<h4>Call Graph Construction</h4>
<p indent="0">1. start from entry methods </p>
<p indent="0">2. for each reachable method  <code-snippet>m</code-snippet> , resolve target methods for each call site  <code-snippet>cs</code-snippet> in  <code-snippet>m</code-snippet> via CHA.  <b>Record every edges</b> .</p>
<p indent="0">3. Repeat until no new method is discovered</p>
<p indent="0">四舍五入就是个图的搜索算法</p>
<h3>Interprocedural Control-Flow Graph (ICFG</h3>
<p indent="0">An ICFG of a program consists of CFGs of the methods in the program, plus two kinds of additional edges:</p>
<p indent="1">-  <b>Call edges</b> : from call sites to the entry nodes of their callees </p>
<p indent="1">-  <b>Return edges</b> : from return statements of the callees to the statements fowllowing their call sites</p>
<code-snippet indent="0" block="true">void foo() {
    bar(…); // call site
    int n = 3; // return site
}
</code-snippet>
<h2>Interprocedural Data-Flow Analysis</h2>
<p indent="0"><b>transfer function</b> : same as intra-procedural constant propagation, plus that</p>
<p indent="1">- for each call node, kill data-flow value for the left-hand-side variable. </p></section>
    </article>
</main>

    </body>
</html>
